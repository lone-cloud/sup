import chalk from 'chalk';
import Imap from 'imap';

const PROTON_BRIDGE_HOST = process.env.PROTON_BRIDGE_HOST || 'protonmail-bridge';
const PROTON_BRIDGE_PORT = Number.parseInt(process.env.PROTON_BRIDGE_PORT || '143', 10);
const BRIDGE_IMAP_USERNAME = process.env.BRIDGE_IMAP_USERNAME;
const BRIDGE_IMAP_PASSWORD = process.env.BRIDGE_IMAP_PASSWORD; // Generated by Proton Bridge

const SUP_SERVER_URL = process.env.SUP_SERVER_URL || 'http://sup-server:8080';
const SUP_API_KEY = process.env.SUP_API_KEY;
const SUP_TOPIC = process.env.SUP_TOPIC || 'Proton Mail';
const VERBOSE = process.env.VERBOSE === 'true';

const log = (...args: unknown[]) => VERBOSE && console.log(...args);

if (!BRIDGE_IMAP_USERNAME || !BRIDGE_IMAP_PASSWORD) {
  console.error(
    chalk.red('Missing required env vars: BRIDGE_IMAP_USERNAME and BRIDGE_IMAP_PASSWORD'),
  );
  console.error(
    chalk.yellow(
      'Run: docker run --rm -it -v proton-bridge-data:/root shenxn/protonmail-bridge init',
    ),
  );
  console.error(chalk.yellow('Then use `login` and `info` commands to get IMAP credentials'));
  process.exit(1);
}

console.log(
  chalk.blue(`ðŸ”— Connecting to Proton Bridge at ${PROTON_BRIDGE_HOST}:${PROTON_BRIDGE_PORT}`),
);
console.log(chalk.blue(`ðŸ“¨ Monitoring mailbox: ${BRIDGE_IMAP_USERNAME}`));
console.log(chalk.blue(`ðŸ”” Sending notifications to: ${SUP_SERVER_URL}/notify/${SUP_TOPIC}`));

const imap = new Imap({
  user: BRIDGE_IMAP_USERNAME,
  password: BRIDGE_IMAP_PASSWORD,
  host: PROTON_BRIDGE_HOST,
  port: PROTON_BRIDGE_PORT,
  tls: true,
  tlsOptions: { rejectUnauthorized: false }, // Proton Bridge uses self-signed cert
  keepalive: true,
});

async function sendNotification(title: string, message: string) {
  try {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    if (SUP_API_KEY) {
      headers.Authorization = `Bearer ${SUP_API_KEY}`;
    }

    const response = await fetch(`${SUP_SERVER_URL}/notify/${SUP_TOPIC}`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ title, message }),
    });

    if (!response.ok) {
      new Error(`SUP server responded with ${response.status}`);
    }

    console.log(chalk.green(`âœ… Notification sent: ${title}`));
  } catch (error) {
    console.error(chalk.red('âŒ Failed to send notification:'), error);
  }
}

function openInbox() {
  imap.openBox('INBOX', false, (err, box) => {
    if (err) {
      console.error(chalk.red('Failed to open inbox:'), err);
    }

    log(`âœ… Connected to inbox (${box.messages.total} messages)`);

    imap.on('mail', async (numNewMsgs: number) => {
      log(`ðŸ“¬ ${numNewMsgs} new message(s) received`);

      const fetch = imap.seq.fetch(`${box.messages.total}:*`, {
        bodies: 'HEADER.FIELDS (FROM SUBJECT)',
        struct: true,
      });

      fetch.on('message', (msg) => {
        msg.on('body', (stream) => {
          let buffer = '';
          stream.on('data', (chunk) => {
            buffer += chunk.toString('utf8');
          });
          stream.once('end', () => {
            const header = Imap.parseHeader(buffer);
            const from = header.from?.[0] || 'Unknown sender';
            const subject = header.subject?.[0] || 'No subject';

            sendNotification('New ProtonMail', `From: ${from}\n${subject}`);
          });
        });
      });
    });

    imap.on('update', () => {
      log('ðŸ“Š Mailbox updated');
    });
  });
}

imap.once('ready', () => {
  log('âœ… IMAP connection ready');
  openInbox();
});

imap.once('error', (err: Error) => {
  console.error(chalk.red('âŒ IMAP error:'), err);
});

imap.once('end', () => {
  log('âš ï¸  IMAP connection ended, reconnecting...');
  setTimeout(() => imap.connect(), 5000);
});

imap.connect();

process.on('SIGTERM', () => {
  log('Shutting down...');
  imap.end();
  process.exit(0);
});

process.on('SIGINT', () => {
  log('Shutting down...');
  imap.end();
  process.exit(0);
});
